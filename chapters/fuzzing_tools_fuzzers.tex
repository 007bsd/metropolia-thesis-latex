% Fuzzing Tools And Fuzzers
 %if the chapter heading starts close to bottom of the page,
 %force a line break and remove the vertical vspace
\vspace{21.5pt}
\chapter{Embedded Fuzzing, Challenges, Tools And Fuzzers}
In this chapter, we explore the significance of embedded system fuzzing in ensuring
the security and reliability of embedded systems. We discuss the comparison between traditional
fuzzing and the unique challenges associated with fuzzing embedded systems.
Next, the available popular fuzzing tools and fuzzers are discussed in terms of
functionality, ease of use, effectiveness and limitations.
In the last section, we dived into the open-source projects and ongoing research
in fuzzing such as AFL++\cite{257204}, libFuzzer\cite{libFuzze17:online},
ClusterFuzz\cite{ClusterF78:online}, OSS-Fuzz\cite{GitHubgo49:online}.

\section{Embedded System Fuzzing}

\subsection{Embedded System}

An Embedded system is compromises of hardware and software components and are often centered around
a microcontroller or microprocessor. These systems are typically designed to perform specific
tasks with a high level of efficiency and accuracy\cite{marwedel2021embedded}.
It interacts with the physical environment and communicates with other devices and consist of a
processor, memory, and peripherals. Firmware, which includes the bootloader, \acrlong{os},
and file system, controls the hardware of an embedded device and is a common
fuzzing target\cite{yun2022fuzzing}.

As embedded devices become increasingly pervasive in our daily lives and in various domains such as the \acrlong{iot}
and automotive systems, their security and reliability become significant concerns.
To ensure the security and reliability of these devices, fuzzing has emerged as an
important testing technique. Specifically, the different fuzzing approaches applied
to embedded systems are referred to as embedded fuzzing\cite{eisele2022embedded}. By subjecting the
embedded systems to a series of tests using malformed or unexpected inputs, the
testing technique helps developers and security researchers uncover and mitigate
potential security threats before they can be exploited in the real world.

The table:\ref{tab:embedded_devices} presents the types of embedded devices, their characteristics,
and the challenges for fuzzing associated with each type\cite{yun2022fuzzing}.

% \begin{table}[h]
% \centering
% \begin{tabularx}{\textwidth}{@{}c>{\raggedright\arraybackslash}p{3.5cm}X@{}}
% \toprule
% \textbf{Type} & \textbf{Characteristics} & \textbf{Challenges for Fuzzing} \\
% \midrule
% 1 & Own processor, memory, and peripherals; simple firmware or RTOS; various communication protocols & Requires specific knowledge of protocols and target hardware \\
% \addlinespace
% 2 & Embedded version of standard OS; advanced features; higher processing power and memory capacity & Requires knowledge of OS internals and system libraries \\
% \addlinespace
% 3 & Entire firmware in a single binary, including OS and applications & Requires full-system emulation or binary disassembly \\
% \bottomrule
% \end{tabularx}
% \caption{Types of Embedded Devices and Their Challenges for Fuzzing}
% \label{tab:embedded_devices}
% \end{table}

\begin{table}[h!]
\centering
\begin{tabularx}{\textwidth}{@{}>{\raggedright\arraybackslash}p{3.5cm}>{\raggedright\arraybackslash}p{3.5cm}X@{}}
\toprule
\textbf{Type} & \textbf{Characteristics} & \textbf{Challenges for Fuzzing} \\
\midrule
Standalone Devices & Own processor, memory, and peripherals; simple firmware or RTOS; various communication protocols & Requires specific knowledge of protocols and target hardware \\
\addlinespace
Devices with Embedded Linux or Other OS & Embedded version of standard OS; advanced features; higher processing power and memory capacity & Requires knowledge of OS internals and system libraries \\
\addlinespace
Monolithic Firmware Devices & Entire firmware in a single binary, including OS and applications & Requires full-system emulation or binary disassembly \\
\bottomrule
\end{tabularx}
\caption{Types of Embedded Devices and Their Challenges for Fuzzing}
\label{tab:embedded_devices}
\end{table}
\clearpage

\subsection{Comparison Between Traditional and Embedded Fuzzing}
Fuzzing aims to discover vulnerabilities in software by providing a system with
unexpected or malformed inputs in both traditional and Embedded system fuzzing.

The table:\ref{tab:fuzzing_comparison} provides the comparison between traditional
and embedded system fuzzing\cite{yun2022fuzzing}\cite{9742291}.

\begin{table}[h!]
\centering
\begin{tabularx}{\textwidth}{@{}>{\raggedright\arraybackslash}p{3cm}X X@{}}
\toprule
        & \textbf{Traditional Fuzzing} & \textbf{Embedded Fuzzing} \\
\midrule
\textbf{Target Systems} & Desktop and server applications, web applications, libraries, etc. & \acrlong{rtos}, IoT devices, firmware, etc. \\
\addlinespace
\textbf{Diverse Targets} & server applications, etc. & Specific hardware and protocols, limited resources, real-time constraints, etc. \\
\addlinespace
\textbf{Challenges} & Input generation, code coverage, etc. & Specific hardware and \acrlong{os} etc. \\
\addlinespace
\textbf{Reliability Constraints} & No time constraints. & limit the time available for fuzzing. \\
\addlinespace
\textbf{Testing Environment} & Simulated or actual systems with standard OS & Emulators,
simulators, or actual devices with specific hardware and protocols \\
\addlinespace
\textbf{Physical Interaction} & Not a primary concern & Must consider environment and physical states of the system \\
\addlinespace
\textbf{Limited Resources} & Not a primary concern & Must optimize fuzzing tools to work efficiently within limited resources \\
\addlinespace
\textbf{Scalability} & Can be easily parallelized to scale with the number of
target applications or libraries & Physical access to the target
devices or emulators, which can limit the scalability  \\
\addlinespace
\textbf{Tools and Techniques} & AFL, libFuzzer, Honggfuzz, etc. & FirmFuzz, IoTcube, FUZZY, etc. \\
\bottomrule
\end{tabularx}
\caption{Comparison of Traditional Fuzzing and Embedded Fuzzing}
\label{tab:fuzzing_comparison}
\end{table}

In addition to the general differences mentioned in the above table, there are more aspects to consider
when doing the comparison.

Traditional fuzzing tools and fuzzers have an easier setup than the embedded fuzzing as the later may
require more manual setup customization due to the wide variety of hardware and software components.
It is easier to integrate and incorporate the traditional fuzzing into \acrlong{ci/cd} as it is more
straightforward. On the contrary, embedded fuzzing may require custom integration due to hardware.
Feedback is usually obtained directly from the target application or library, making it easier to
monitor the fuzzing process and identify issues. In embedded fuzzing, feedback might come
from multiple sources, including the target device's firmware, hardware components.

\subsection{Challenges in Embedded Fuzzing}
Fuzzing embedded systems presents distinct challenges and complexities,
necessitating the development of specialized tools and strategies to ensure
their security and reliability. In this subsection, we delve into the primary
concerns and obstacles that researchers and practitioners face when conducting
fuzz testing on embedded systems, highlighting the need for innovative approaches
to tackle these challenges effectively.

\Citeauthor{yun2022fuzzing} states below,
\begin{itemize}
\item Heterogeneous targets: Embedded systems have different hardware,
operating systems, and communication protocols\cite{yun2022fuzzing}.
\item Limited resources: Embedded systems typically have limited resources,
such as processing power and memory, which can restrict the use of
traditional fuzzing techniques\cite{yun2022fuzzing}.
\item Real-time and reliability constraints: Some embedded systems have
real-time requirements, and fuzzing should not disrupt their normal operation\cite{yun2022fuzzing}.
\item Scalability: It often requires physical access to target devices or
emulators, limiting the scalability of fuzzing efforts\cite{yun2022fuzzing}.
\end{itemize}

\Citeauthor{muench2018you} states below,
\begin{itemize}
\item Limited visibility: The internal state of embedded systems is
often difficult to observe, making it harder to understand the impact of
fuzz testing and identify issues\cite{muench2018you}.
\item Difficulties in reproducing crashes: Due to the diverse nature of
embedded systems and the use of custom hardware, it may be challenging to
reproduce crashes consistently and accurately\cite{muench2018you}.
\item Challenges in determining the root cause of crashes: Difficulties in
identifying the root cause of crashes in embedded systems\cite{muench2018you}.
\end{itemize}

\Citeauthor{eisele2022embedded} states below,
\begin{itemize}
\item Physical interaction: Embedded systems often interact with the
physical world, which can make fuzzing more challenging\cite{eisele2022embedded}.
\item Device-specific hardware and protocols: Embedded devices often use
custom hardware components and communication protocols, which may not be
compatible with existing fuzzing tools and techniques\cite{eisele2022embedded}.
\item Lack of source code: In many cases, the source code for embedded
systems may not be available, making it difficult to analyze the software
for potential vulnerabilities and develop appropriate fuzzing test cases\cite{eisele2022embedded}.
\end{itemize}

\Citeauthor{manes2019art} states the below,
\begin{itemize}
\item Stateful applications: Fuzzing stateful applications, such as network
protocols or multi-threaded applications, presents additional challenges.
Properly handling state transitions, synchronization, and concurrent execution
is critical for effectively fuzzing these types of applications\cite{manes2019art}.
\item Oracle problem:  In some cases, determining whether a given input has
triggered a vulnerability can be challenging. Fuzzers often rely on simple
oracles, such as crashes, which may not be sufficient to detect all
types of vulnerabilities\cite{manes2019art}.
\item Performance: The performance of fuzzers is critical for their effectiveness.
Slow fuzzers may not be able to explore enough execution paths to find
vulnerabilities in a reasonable amount of time.\cite{manes2019art}.
\end{itemize}

\subsection{Fuzzing Tools and Fuzzers}

This section on Fuzzing Tools and Fuzzers covers various tools and techniques
for fuzz testing, including those that can be used for both general
software and embedded systems. Additionally, this section provides an
overview of the features and limitations of these tools,
which can assist practitioners in selecting the appropriate tool
for their specific needs. They have been effective in discovering and
mitigating security issues, which has contributed to their popularity
and widespread adoption.

% \begin{itemize}
% \item \textbf{AFL (American Fuzzy Lop):}\cite{zalewski2014american}\cite{GitHubgo92:online} \\
% \emph{Functionality:}Coverage-guided, genetic algorithms, binary program fuzzing \\
% \emph{Ease of use:}  Simple setup, easy to use for most users \\
% \emph{Effectiveness:} Widely adopted, has discovered numerous vulnerabilities in widely-used software \\
% \emph{Limitations:} Lacks support for multi-threaded applications, and limited effectiveness in fuzzing structured data formats

% \item \textbf{libFuzzer:}\cite{libFuzze17:online} \\
% \emph{Functionality:} Coverage-guided, in-process fuzzing, targets libraries with well-defined APIs \\
% \emph{Ease of use:} Easy integration with LLVM-based projects, requires writing custom harness code \\
% \emph{Effectiveness:} Has found vulnerabilities in widely-used libraries and software components \\
% \emph{Limitations:} In-process fuzzing can result in performance bottlenecks, limited support for non-LLVM compilers

% \item \textbf{honggfuzz:}\cite{GitHubgo89:online} \\
% \emph{Functionality:} Security-oriented, supports multiple platforms and feedback signals \\
% \emph{Ease of use:} Moderate setup complexity, flexible configuration options \\
% \emph{Effectiveness:} Effective in identifying vulnerabilities in various types of software \\
% \emph{Limitations:} Lacks the ease of use and setup simplicity compared to AFL, limited documentation

% \item \textbf{Peach Fuzzer:}\cite{PeachFuz35:online} \\
% \emph{Functionality:} Commercial framework, custom data models and state machines, supports various target platforms \\
% \emph{Ease of use:} Can be complex to set up, offers a graphical user interface (GUI) for ease of use \\
% \emph{Effectiveness:} Widely used in industry, has discovered vulnerabilities in numerous software systems \\
% \emph{Limitations:} Proprietary software, high cost, steep learning curve for complex testing scenarios

% \item \textbf{Boofuzz:}\cite{pereyda2019boofuzz} \\
% \emph{Functionality:} Network protocol fuzzing, custom protocol specifications \\
% \emph{Ease of use:} Moderate setup complexity, flexible configuration options \\
% \emph{Effectiveness:} Effective in finding vulnerabilities in network protocols and services \\
% \emph{Limitations:} Limited support for non-network protocol targets, can be complex to configure for custom protocols

% \item \textbf{Radamsa:}\cite{AkiHelin96:online} \\
% \emph{Functionality:} General-purpose, black-box fuzzer for file formats, network protocols, and command-line utilities \\
% \emph{Ease of use:} Simple to set up and use, especially for black-box testing scenarios \\
% \emph{Effectiveness:} Has identified vulnerabilities in a wide range of software \\
% \emph{Limitations:} Lacks feedback-driven fuzzing capabilities, limited in identifying complex vulnerabilities

% % \item \textbf{AFL++:}\cite{257204} \\
% \emph{Functionality:} Enhanced version of AFL with improved mutation strategies and performance \\
% \emph{Ease of use:} Similar to AFL, simple setup, and easy to use for most users \\
% \emph{Effectiveness:} Inherits AFL's effectiveness and adds various improvements \\
% \emph{Limitations:} Still inherits some limitations of AFL, such as the lack
% of support for multi-threaded applications and structured data formats

% \item \textbf{For fuzzing embedded systems}:
% \item \textbf{FirmFuzz:}\cite{srivastava2019firmfuzz}\cite{yun2022fuzzing} \\
% \emph{Functionality:} Automated IoT firmware introspection and analysis \\
% \emph{Ease of use:} Requires understanding of firmware images and emulation \\
% \emph{Effectiveness:} Useful for identifying vulnerabilities in firmware images \\
% \emph{Limitations:} Limited to firmware images, requires specific knowledge and expertise in firmware analysis

% \item \textbf{Firmadyne:}\cite{chen2016towards} \\
% \emph{Functionality:} Emulation and dynamic analysis of Linux-based embedded firmware \\
% \emph{Ease of use:}  Moderate setup complexity, requires knowledge of firmware and Linux systems \\
% \emph{Effectiveness:} Effective in analyzing firmware for potential vulnerabilities \\
% \emph{Limitations:} Limited to Linux-based firmware, emulation may not accurately represent the actual hardware environment

% \item \textbf{AVATAR:}\cite{zaddach2014avatar} \\
% \emph{Functionality:} Framework for dynamic analysis and instrumentation of embedded systems \\
% \emph{Ease of use:} Requires understanding of embedded systems and experience with dynamic analysis \\
% \emph{Effectiveness:} Can be effective when combined with fuzzers for analyzing embedded firmware \\
% \emph{Limitations:} Steep learning curve, requires customization for specific target systems
% \end{itemize}

The table:\ref{tab:fuzzers_table} showcases Fuzzing Tools and Fuzzers for traditional
and embedded fuzzing.
\begin{longtable}{>{\raggedright}p{2.1cm}>{\raggedright}p{3cm}>{\raggedright}p{3cm}>{\raggedright\arraybackslash}p{5cm}}
\caption[Different Types of Fuzzers]{Types of Fuzzers}
\label{tab:fuzzers_table}\\
\toprule
\textbf{Name} & \textbf{Functionality} & \textbf{Ease of use} & \textbf{Effectiveness and Limitations} \\
\midrule
\endfirsthead
\multicolumn{4}{c}%
{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
\toprule
\textbf{Name} & \textbf{Functionality} & \textbf{Ease of use} & \textbf{Effectiveness and Limitations} \\
\midrule
\endhead
\acrshort{afl}\cite{zalewski2014american}\cite{GitHubgo92:online} & Coverage-guided,
genetic algorithms, binary program fuzzing & Simple setup, easy to use & Widely
adopted, has discovered numerous vulnerabilities. Lacks support for
multi-threaded applications, and limited effectiveness in fuzzing structured data formats \\
\midrule
libFuzzer\cite{libFuzze17:online} & Coverage-guided, in-process fuzzing, targets libraries with
well-defined APIs & Easy integration with LLVM-based projects, requires writing custom harness
code & Has found vulnerabilities in widely-used libraries and software components. In-process
fuzzing can result in performance bottlenecks, limited support for non-LLVM compilers \\
\midrule
honggfuzz\cite{GitHubgo89:online} & Security-oriented, supports multiple platforms and
feedback signals & Moderate setup complexity, flexible configuration options & Effective in
identifying vulnerabilities in various types of software. Lacks the ease of use and setup
simplicity compared to AFL, limited documentation \\
\midrule
Peach Fuzzer\cite{PeachFuz35:online} & Commercial framework, custom data models and state machines,
supports various target platforms & Can be complex to set up, offers a \acrlong{gui} for ease of
use & Widely used in industry, has discovered vulnerabilities
in numerous software systems. Proprietary software, high cost, steep learning curve for complex testing scenarios \\
\midrule
Boofuzz\cite{pereyda2019boofuzz} & Network protocol fuzzing, custom protocol
specifications & Moderate setup complexity, flexible configuration options & Effective in finding
vulnerabilities in network protocols and services. Limited support for non-network protocol
targets, can be complex to configure for custom protocols \\
\midrule
Radamsa\cite{AkiHelin96:online} & Black-box fuzzer for file formats, network
protocols, and command-line utilities & Simple to use for black-box testing
scenarios & Has identified vulnerabilities in a wide range of software. Lacks feedback-driven
fuzzing capabilities, limited in identifying complex vulnerabilities \\
\midrule
AFL++\cite{257204} & Enhanced version of AFL with improved mutation strategies and
performance & Similar to AFL, simple setup, and easy to use for most users & Inherits
AFL's effectiveness and adds various improvements. Still inherits some limitations of AFL,
such as the lack of support for multi-threaded applications and structured data formats \\
\midrule
FirmFuzz\cite{srivastava2019firmfuzz}\cite{yun2022fuzzing} & Automated \acrshort{iot} firmware
introspection and analysis & Requires understanding of firmware images and emulation & Useful for
identifying vulnerabilities in firmware images. Limited to firmware images, requires specific
knowledge and expertise in firmware analysis \\
\midrule
Firmadyne\cite{chen2016towards} & Emulation and dynamic analysis of Linux-based embedded
firmware & Moderate setup complexity, requires knowledge of firmware and Linux systems & Effective
in analyzing firmware for potential vulnerabilities. Limited to Linux-based firmware, emulation may
not accurately represent the actual hardware environment \\
\midrule
AVATAR\cite{zaddach2014avatar} & Framework for dynamic analysis and instrumentation of embedded
systems & Requires understanding of embedded systems and experience with dynamic analysis & Can be
effective when combined with fuzzers for analyzing embedded firmware. Steep learning curve,requires
customization for specific target systems \\
\midrule
\end{longtable}

\subsection{Open-source Projects and Ongoing Research}
In this section, we explore open-source projects and ongoing research in the field of fuzzing.
Fuzzing has gained significant attention in recent years due to its effectiveness in
discovering vulnerabilities in software systems. As a result, researchers
and practitioners are actively working on developing novel fuzzing techniques
and tools to address the unique challenges posed by various target systems,
including embedded systems, network protocols, and operating systems.

We discuss several prominent open-source fuzzing projects, such as Google's
OSS-Fuzz\cite{GitHubgo49:online}, several Afl based fuzzers and the
GitHub repository dedicated to fuzzing research. These projects aim to advance the state-of-the-art
in fuzzing by providing a platform for collaboration and knowledge sharing among the fuzzing community.

By providing an overview of open-source projects and ongoing research in fuzzing,
this section aims to offer valuable insights into the current state and
future directions of fuzzing as a critical technique in software security testing.

\textbf{OSS-Fuzz:\cite{GitHubgo49:online}} \\
OSS-Fuzz is an open-source fuzzing service developed by Google, aiming to
improve the security and stability of open-source software projects.
By providing continuous fuzzing for select projects, OSS-Fuzz helps to
identify and address critical vulnerabilities and bugs before they become
potential exploits in widely-used software.
OSS-Fuzz integrates with various fuzzing engines, such as libFuzzer and AFL,
and supports multiple programming languages, including C, C++, Rust, and Go\cite{GitHubgo49:online}.

One of the primary goals of OSS-Fuzz is to encourage the adoption of fuzzing as
a standard practice in the open-source community. Projects that integrate with
OSS-Fuzz receive regular feedback on newly discovered vulnerabilities,
enabling developers to address issues promptly and maintain a higher
level of software security\cite{GitHubgo49:online}.

\textbf{Fuzzbench: \cite{GitHubgo32:online}}\\
Fuzzbench is a is a benchmarking service developed and supported by Google. It helps
fuzzers that aim to evaluate and compare different fuzzing techniques. It
provides a standardized testing environment for fuzzers,
allowing developers to evaluate the performance of their fuzzers
against other popular tools and provide reports as well\cite{FuzzBenc32:online}.
Fuzzbench is a valuable tool for researchers and developers seeking to improve
the state of fuzzing techniques.


\textbf{OneFuzz: \cite{GitHubmi60:online}}\\
OneFuzz is a fuzzing-as-a-service platform developed by Microsoft, that aims to
automate the detection and reporting of software bugs. It is a self-hosted
platform that provides a range of features, including task scheduling,
crash analysis, and distributed fuzzing. OneFuzz can be integrated with
existing development workflows, making it a useful tool for organizations
looking to improve the security and stability of their software systems

\textbf{Afl Based Fuzzers:}\\
\acrlong{afl} is a coverage-guided, or feedback-based, fuzzer that utilizes a
dynamic approach to identify potential vulnerabilities in software applications.
It modifies the target executable to measure and optimize code coverage,
mutating input data in a manner that maximizes the coverage achieved.
This process is iteratively repeated, seeking to uncover instances in
which the program crashes, thereby identifying potential security vulnerabilities.
AFL has proven to be highly effective in practice, as evidenced by its extensive
usage and success in uncovering numerous vulnerabilities in widely-used software.
Furthermore, AFL is renowned for its ease of use, making it a popular choice
among security researchers and practitioners\cite{american20:online}\cite{fuzzinga40:online}.

Several fuzzers have been developed based on AFL's architecture, enhancing its
capabilities or tailoring it for specific use cases. Some notable AFL-based
fuzzers mentioned below:

\begin{itemize}
\item \textbf{AFL++:\cite{257204}\cite{GitHubAF78:online}} \\
An enhanced version of AFL which
introduces various performance improvements and new features, such as improved mutation strategies,
faster execution, more and better mutations, improved instrumentation, and custom module support.
\item \textbf{AFLFast:\cite{GitHubmb97:online}} \\
A fuzzer that introduces a power schedule, aiming to prioritize
seeds that are more likely to explore new paths and increase coverage.
By doing so, AFLFast aims to improve the efficiency of fuzzing and maximize
the code coverage in a shorter time frame\cite{bohme2016coverage}.
\item \textbf{TriforceLinuxSyscallFuzzer:\cite{GitHubnc62:online}} \\
This fuzzing technique specifically targets Linux system calls,
aiming to identify potential vulnerabilities in the system call interface.
\item \textbf{AFL-unicorn:\cite{GitHubBa48:online}} \\
Afl-unicorn is a versatile AFL modification that enables fuzzing across various architectures,
source code availability, input data formats, and binary formats (e.g., bare-metal firmware like Wi-Fi or baseband).
The process involves first examining the binary and developing a fuzzer that emulates the state at
the input of the parser procedure. AFL-unicorn uses a combination of AFL's coverage-guided fuzzing
technique and Unicorn's emulation capabilities to explore the different execution paths
of the target binary\cite{aflunico82:online}.
\end{itemize}

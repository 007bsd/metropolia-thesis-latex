% Theoretical background
%\clearpage%if the chapter heading starts close to bottom of the page, force a line break and remove the vertical vspace
\vspace{21.5pt}
\chapter{Theoretical background: Software And Software Testing}
This chapter explores the concept of computer software and its foundational
theory as it applies to software testing. The discussion begins with a
comprehensive overview of computer software and its historical progression.
Subsequently, the focus shifts to the crucial aspects of software testing.
The discussion ends with an examination of software quality, examining different
quality attributes and highlighting their significance in developing and
maintaining top-quality software systems.
%\section{Computer Software, Software Testing and Information Security}

\section{Computer Software}
Computer software, also known as programs or applications, encapsulates a set of instructions that
enable interaction with a computer or digital device to accomplish a broad array of
tasks~\cite{Software76:online}. This includes operating systems~\cite{stallings1998operating},
application software~\cite{Definiti63:online} such as
word processors or graphic design tools, and more complex systems like databases or
scientific simulations~\cite{Definiti63:online}.

Software can be classified into various categories, with one crucial distinction
being between system software, which governs the fundamental functions of a
computer or network, and application software, which executes tasks for the
user~\cite{WhatisSy89:online}\cite{Definiti63:online}.
Additionally, software can be classified as local, denoting that it operates on
the user's device, or web-based, meaning it functions on remote servers and is
accessed via the internet. A growing amount of software is crafted for handheld
devices such as smartphones and tablets, commonly referred to as mobile
applications or `apps'~\cite{yetisen2014regulation}.

The evolution of software development dates back to the 1950s and 60s when low-level assembly
languages were prevalent~\cite{lehman2002software}. However, from the 1970s onward, high-level
languages providing a greater degree of abstraction from the hardware~\cite{WhatisHa66:online}
have become the norm. For example, the C programming language, created at Bell
Labs in the early 1970s, is widely used in system programming and embedded
systems~\cite{kernighan2002c}.
Python, introduced in 1991, has gained popularity in fields like web development,
data analysis, and artificial intelligence due to its emphasis on code readability and a
comprehensive standard library~\cite{van2007python}. Programming languages like
Swift~\cite{rebouccas2016empirical} and Kotlin~\cite{samuel2017programming},
introduced in 2014 and 2011 respectively, have been officially adopted by Apple and Google
for iOS~\cite{WhatIsSw25:online} and Android mobile app development~\cite{WhatIsKo37:online}.
These languages, while newer, have quickly gained traction due to their ease of use,
and support from their respective tech giants.

The emergence of these languages and many others has contributed to the rich,
diverse landscape of software development. The choice and development of
programming languages are influenced by factors like project needs, efficiency,
user-friendliness, and the continuous advancement and change in technology~\cite{goosen2008brief}.

The integration of software into various aspects of life and business operations
has highlighted the importance of delivering high-quality, error-free software
applications~\cite{kahn2002information}. This need stems from several factors.
User expectations have heightened, necessitating software that meets functional
requirements while providing seamless and intuitive interfaces~\cite{ryker1997determinants}.
Furthermore, system reliability is crucial as software failures can result in significant
consequences such as financial losses, compromised safety, and
tarnished company reputations~\cite{pham2007system}.
Regulatory and compliance requirements also mandate specific performance and reliability standards,
especially in sectors like healthcare, finance, and aviation~\cite{mishra2022cybersecurity}. Moreover,
in today's competitive business environment, the quality of software can be a key differentiator
that affects customer loyalty and market share~\cite{rust1993customer}. Although
these factors are important, many software applications still experience
problems because they do not follow strict software engineering practices like
gathering requirements, designing systems, implementing, testing, and
maintenance properly. Therefore, strong software engineering methods are
essential to prevent system failures and help develop dependable software
systems.

Software quality is a complex idea that includes different features which decide
how well a software product satisfies the needs and expectations of its users.~\cite{boehm1976quantitative}.
These attributes can be broadly categorized into functional and non-functional aspects.
Functional quality is about how well the software does its intended jobs. It
includes things like how accurate, reliable, and correct the software's results
are.~\cite{kiruthika2015software}. On the other hand,
non-functional quality pertains to the overall performance and usability of the software,
including efficiency, scalability, maintainability, usability, security, and portability~\cite{chung2012non}.
Evaluating software quality is a complex task that requires comprehensive testing and analysis
methodologies. Ioftware quality is important throughout the entire \acrshort{sdlc},
starting from gathering requirements to designing,
implementing, and maintaining the system. Good software quality is crucial
because it affects how happy users are, how reliable the system is, and how well
the software fulfills its intended purpose. Therefore, investing in quality assurance and testing
procedures is a crucial aspect of software engineering, aimed at identifying and rectifying defects,
improving the user experience, and ensuring the delivery of robust, high-performing software
products~\cite{cavano1978framework}.

Good software results in happy customers, keeps them coming back, and ultimately
leads to higher profits. According to \citeauthor{8748529}, a process with
strict quality standards produces high-quality products. Testing is a crucial
step in making software to make sure it is of high quality~\cite{8748529}.

The Figure:~\ref{fig:software_quality_perspective} describes different software quality perspectives
and its dependencies.

\begin{figure}[H]
    \centering
    \AltText{Diagram of Software Quality Perspective, highlighting eight key
    aspects: Security & Compliance, Maintainability & Support, End User's Experience,
    Business Requirements, Development Team's Perspective, Market Study,
    Testing & Validation, and Performance & Scalability. These elements
    collectively define the multifaceted nature of software quality.}
    {\adjustbox{width=\textwidth}{\includegraphics{illustration/software_quality_perspective.png}}}
    \caption{Software Quality Perspective}~\label{fig:software_quality_perspective}
\end{figure}



\section{Software Testing}

According to \citeauthor{whittaker2000software}, the process of software testing
is frequently misunderstood or not fully grasped in the area of software
development.~\cite{whittaker2000software}. It serves as a means of
evaluating and verifying a software program to determine its alignment with technical and business
requirements, as well as user expectations and overall functionality~\cite{bentley2005software}.
Additionally, as noted by \citeauthor{jamil2016software}, software testing is a risk-based activity
that aims to uncover bugs, errors, unmet requirements, and vulnerabilities. Through this process,
confidence in the behavior and requirements of the program can be gained~\cite{jamil2016software}.

Software testing is a costly endeavor, and it is impossible for any software program to be completely
devoid of bugs or errors. As depicted in Figure:~\ref{fig:software_testing_quality},
there is a link between the quality of software and how much effort is put into
testing it. In particular, when more money is spent on testing, the software's
quality gets better, and there are fewer bugs in relation to the amount of
testing done. The decision on when to stop testing depends on different factors
like time limits, budget restrictions, and how extensive the testing is.


% \begin{figure}[ht]
% \centering
% \AltText{Testing Effort vs Quality}{\includegraphics[width=12.1cm]{software_testing_quality}}
% \caption{Testing Effort vs Quality\cite{arumugam2019software}}\label{fig:software_testing_quality}
% \end{figure}

\begin{figure}[h]
    \AltText{Graph depicting the relationship between Testing Effort and
    Software Quality. The X-axis represents the Amount of Testing,
    increasing from left to right, and the Y-axis represents Quality,
    increasing from bottom to top. The graph illustrates how software
    quality tends to improve with increased testing effort, showing a
    positive correlation between the two variables.}{\adjustbox{width=\textwidth}{\includegraphics{software_testing_quality}}}
    \caption{Testing Effort vs Quality~\cite{arumugam2019software}}~\label{fig:software_testing_quality}
\end{figure}

\subsection{Software Testing Quality Attributes}

Methods and characteristics of software testing are very important in the
\acrshort{sdlc}. They help improve quality processes and
methods. One important part of software testing is static analysis techniques~\cite{zheng2006value}, which encompass inspections and reviews.
These techniques are essential attributes in ensuring the quality of the software and serve as a complement to
traditional software testing methods.

\subsubsection{Software Attributes}

Software attributes are features of software testing that help in explaining the
overall quality of a software program.

The attributes of software quality~\cite{mili2015software} given in
the Table:~\ref{tab:software-attributes}.

\begin{table}[H]
    \centering
\caption{Software Quality Attributes}
\label{tab:software-attributes}
\begin{tabularx}{\textwidth}{lX}
\toprule
\textbf{Attribute} & \textbf{Description} \\
\midrule
Interoperability & The ability of the software to operate seamlessly in different operating systems and machines. \\
Simplicity & The ease of use, avoiding misuse, and interactions with other systems. \\
Ease of Learning & The ability of the software to adapt and improve through system interactions and output logs. \\
Customizability & The software's capability to be set up or modified to suit the particular requirements of a user or an organization. \\
Calibrability & The ability of the software to be fine-tuned for optimal performance and accuracy. \\
Reliability & The ability of the software to perform its intended functions without failure or external influence. \\
Functionality & The features and capabilities of the software, organized in a modular manner to conceal information. \\
Portability & The capacity of the software to operate on various platforms and
hardware setups. \\
Reusability & How easily the software can be changed, adapted, and reused. \\
\bottomrule
\end{tabularx}
\end{table}

These attributes are very important in the software development process, making
sure that the software meets the needed quality standards and is easy for users
to work with.

% \subsection{Software Testing Methods}
% Software Testing is classified into different testing methods to evaluate the correctness of the software
% in a \acrshort{sdlc}. It is an art, and is not mature and constantly evolving. Static and dynamic analysis
% are two different approaches are practiced in software testing and are important in \acrshort{sdlc}.


% \subsubsection{Static Analysis}
% Static analysis is performed early in the \acrshort{sdlc}. It helps in finding the bugs early and at this
% stage the fixing a bug is lot cheaper than fixing it in the later stage of the \acrshort{sdlc}.
% It is performed not by executing the program, but analyzing the source code.
% Static analysis tools are used to analyze the code or the program as a whole automatically.

% Below are the issues uncovered by the static analysis tools,
% \begin{itemize}
%         \item Static Bugs
%         \item Securities vulnerabilities
%         \item Unused and dead code
%         \item Syntax and semantic errors
%         \item Code complexity and Standard violations
% \end{itemize}

% \subsubsection{Dynamic Analysis}
% Dynamic analysis is opposite to the static analysis where the correctness of the software is evaluated
% by executing the software and the source code. It helps in collecting data about memory usage, performance
% and usually performed during the development, testing and production environment. For the automation,
% different dynamic tools are used.

% Dynamic tools are used to detect below issues,

% \begin{itemize}
%         \item Memory leaks and performance issues
%         \item Thread locks and garbage collection issues
%         \item Unused and dead code
%         \item Exceptions and error conditions
%         \item Code complexity and Standard violations
% \end{itemize}

%\subsection{Software Testing Types And Techniques}
% The classification of software testing into functional testing and non-functional
% testing is essential for ensuring the quality and functionality of software
% programs.

% Functional testing concentrates on verifying the software's conformity with specified requirements,
% whereas non-functional testing focuses on evaluating the software's performance, security,
% usability, and other non-functional attributes. Both forms of testing can be executed at various
% stages of the software development life cycle and can be automated through the use of specialized
% tools and frameworks.

% The Figure~\ref{fig:software_testing_types} illustrates different functional and non-functional
% testing.

% \begin{figure}[ht]
%         \centering
%         \AltText{Software Testing Types}{\includegraphics[width=12.1cm]{software_testing_types}}
%         \caption{Software Testing Types}\label{fig:software_testing_types}
% \end{figure}

% \subsubsection{Functional Testing}
% Functional testing is a type of testing that focuses on assessing the functionality of software
% with respect to compliance with specific requirements. This form of testing involves evaluating
% inputs, outputs, and system behaviors from the perspective of the end user to guarantee that the
% software is functioning as intended. As a result, functional testing is often referred to as
% ``specification-based testing'' as it verifies that the software adheres to the
% specified requirements\cite{Differen44:online}.

% The common types of functional testing include:

% \begin{itemize}
%         \item Unit Testing: The testing of individual components or units of a
%         program to determine their proper functioning.
%         \item Integration Testing: The testing of the integration of various
%         components or units to ensure that they interact with each other as intended.
%         \item System Testing: The testing of the entire system,
%         including units and integrated components, as a whole.
%         \item Regression Testing: The process of verifying the software after functional changes
%         have been made to other parts of the software to ensure that existing functionalities
%         still operate as expected.
%         \item Exploratory Testing: An ad-hoc and spontaneous examination of
%         the software to uncover new issues or bugs.
%         \item User-Acceptance Testing: The evaluation of the software to ensure
%         that it meets the expectations of the end-user.
% \end{itemize}


% \subsubsection{Non-Functional Testing}
% Non-functional testing encompasses a wide range of testing types that are aimed at evaluating the
% software's performance, reliability, usability, and security, among other non-functional attributes.
% These attributes are critical for determining the overall quality and suitability of the software
% for its intended purpose. Some common types of non-functional testing include load testing,
% volume testing, stress testing, security testing, compatibility testing, and
% usability testing, among others.

% These tests are designed to assess the software's ability to perform under varying conditions,
% such as high volumes of traffic, increased usage, and security attacks. The results of
% non-functional testing can provide valuable insight into the software's strengths
% and weaknesses, and can inform decisions about future development and improvement efforts.

% The common types of Non-Functional testing include,
% \begin{itemize}
%         \item The evaluation of the system's expected performance from the end user's perspective.
%         This type of testing assesses the system's throughput, response time, or a combination of
%         both, to determine its performance\cite{weyuker2000experience}.
%         \item Usability Testing: The assessment of the software's ease of use,
%         with a focus on user experience. This type of testing evaluates the software's
%         functionality, navigation, and overall usability.
%         \item Security Testing: The examination of the software to ensure that it functions as
%         intended in the presence of malicious attacks, such as hacking attempts, viruses,
%         and other security threats. This type of testing verifies the software's security features,
%         including encryption, authentication, and authorization.
% \end{itemize}

% \subsection{Software Testing Categories}
% Software testing is commonly categorized into three distinct types:
% black-box testing, white-box testing, and gray-box testing.

% These categories are defined by the level of information available during the testing process.
% In each of these categories, test cases are devised to thoroughly test the software and ensure
% its quality and functionality. The choice of testing category is determined by the extent to
% which the internal structure of the software is known and can be used to inform the
% testing process.
% \clearpage

% The Figure~\ref{fig:software_testing_categories} illustrates different software categories.

% \begin{figure}[ht]
%         \centering
%         \AltText{Software Testing Categories}{\includegraphics[width=12.1cm]{software_testing_categories}}
%         \caption{Software Testing Categories\cite{jamil2016software}\cite{jovanovic2006software}.}\label{fig:software_testing_categories}
% \end{figure}

% \subsubsection{White-box Testing}

% White-box testing, also known as ``structural testing'' or ``clear-box testing'',
% is a type of software testing that requires access to the software's source code,
% requirements, and specification documents. This type of testing is based on the software's
% internal structures and implementation details and often involves source code
% review\cite{abran2001guide}.

% White-box testing covers unit testing, branch testing, integration testing, and control flow testing.
% The process of white-box testing is typically performed by developers and requires an understanding
% of the software's internal structure. Automated test frameworks and tools, including code coverage
% tools, are often used to perform white-box testing. Fuzzing techniques can also be used to uncover
% problems. Due to early detection, bugs found during the white-box testing phase of the \acrlong{stlc}
% are generally less expensive to fix\cite{miller1981introduction}.


% \subsubsection{Black-box Testing}
% In the Black-box Testing approach, the focus is on the inputs, expected outputs, and functionalities
% of the software, without taking into consideration the internal working of the system. This type of
% testing is also known as  ``behavioral testing'' or  ``functional testing''. The testers are unaware
% of the internal workings of the software, which helps to identify any issues that may arise
% from the end-user's perspective.

% This testing technique is performed in various stages of the \acrshort{sdlc} and is widely used to
% test the functionality of the software. The test cases are designed based on the user requirements
% and functional specifications. The testers are not required to have any knowledge of the code, which
% makes it a cost-effective testing method as it does not require specialized skills or in-depth
% knowledge of the software. Automated testing tools can also be used to perform Black-box Testing,
% which can increase the efficiency and speed of the testing
% process\cite{jamil2016software}\cite{pudas2017improving}.

% Fuzzing is a commonly used technique within the Black-box Testing methodology. It involves the
% evaluation of the software's inputs, outputs, and behaviors. Black-box fuzzing is considered to
% be less complex in comparison to White-box fuzzing, and it offers faster and lighter testing but
% with limited coverage. On the other hand, White-box fuzzing is more complex, requiring more time
% and resources, but it provides a broader coverage of the software's internal structures and
% functionalities\cite{godefroid2008grammar}.

% \subsubsection{Gray-box Testing}
% The Gray-box Testing technique is a combination of the black-box and white-box testing methods,
% which is typically executed by both software developers and quality assurance teams within the
% \acrshort{sdlc}. This testing approach encompasses regression testing, pattern testing,
% and matrix testing and necessitates knowledge about both the internal architecture and end-to-end
% functionality of the software\cite{jamil2016software}.

% Reverse engineering and manipulation of the binary in black-box fuzzing can result in gray-box
% fuzzing, where the fuzzing tool inserts instructions and instrumentation into the precompiled
% black-box binary to provide the fuzzers with the necessary information. Regression testing,
% pattern testing, and matrix testing are common examples of gray-box
% testing\cite{wilson2018evaluation}.
\clearpage
% -----------------
% Academic end check

%  -----------------